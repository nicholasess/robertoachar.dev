---
slug: typescript-class-interface
title: TypeScript - Classes vs Interfaces
description: Neste artigo pretendo apresentar uma comparaÃ§Ã£o entre a utilizaÃ§Ã£o de `classes` e `interfaces`.
date: 2017-08-14
category: Artigo
tags: [javascript, typescript]
photo: ./photo.jpg
photoCredit: Giammarco Boscaro
photoLink: https://unsplash.com/photos/UkOpMcslmX8
---

Neste artigo pretendo apresentar uma comparaÃ§Ã£o entre a utilizaÃ§Ã£o de `classes` e `interfaces` para a representaÃ§Ã£o do modelo de dados.

- IntroduÃ§Ã£o
- Preparando o ambiente de desenvolvimento
- Construindo os testes
- Analisando o comportamento com Interfaces
- Analisando o comportamento com Classes
- ConclusÃ£o

## IntroduÃ§Ã£o

`TypeScript` possui o conceito de `classes` e `interfaces`, onde ambos podem ser utilizados para representar o modelo de dados dos nossos objetos. Uma dÃºvida que encontro bastante em fÃ³runs Ã© a seguinte:

> Devo utilizar classes ou interfaces para representar meu modelo de dados?

O objetivo desse artigo Ã© apresentar o veredicto final e esclarecer qualquer dÃºvida referente ao assunto.

## Preparando o ambiente de desenvolvimento

Nessa seÃ§Ã£o vou descrever os passos que utilizei para preparar o ambiente de desenvolvimento para realizar os testes de comparaÃ§Ã£o.

- Criando o projeto

```bash
$ npm init -y
```

- Instalando as dependÃªncias de desenvolvimento

```bash
$ npm install --save-dev concurrently
$ npm install --save-dev typescript
```

- Criando o ponto de entrada

Criei o diretÃ³rio `src` e dentro dele adicionei o arquivo `index.ts` com o seguinte conteÃºdo.

```typescript
console.log('It works!');
```

- Definindo as configuraÃ§Ãµes de transpilaÃ§Ã£o

Na raiz do projeto, criei o arquivo `tsconfig.json` com as seguintes configuraÃ§Ãµes.

```json
{
  "compilerOptions": {
    "outDir": "./build",
    "allowJs": true,
    "target": "es5"
  },
  "include": ["./src/**/*"]
}
```

Esse arquivo irÃ¡ transpilar os arquivos `.ts` que estÃ£o no diretÃ³rio `src` para o diretÃ³rio `build`.

- Configurando a transpilaÃ§Ã£o e execuÃ§Ã£o do projeto

Criei o `script` de inicializaÃ§Ã£o do projeto no arquivo `package.json`.

```json
...
  "scripts": {
    "start": "concurrently \"tsc -w\" \"nodemon build/index.js\" "
  },
...
```

O comando `tsc -w` coloca o compilador em modo `watch` e a cada alteraÃ§Ã£o nos arquivos do diretÃ³rio `src`, o compilador transpila o cÃ³digo para o diretÃ³rio `build` automaticamente. O comando `nodemon build/index.js` executa o projeto. Caso algum arquivo `.js` seja alterado, o `nodemon` reinicia a execuÃ§Ã£o.

- Executando o projeto

```bash
$ npm start
```

- Validando o ambiente de desenvolvimento

O arquivo `index.js` deverÃ¡ ser criado no diretÃ³rio `build` e a saÃ­da do programa deverÃ¡ ser `It works!`.

## Construindo os testes

O cenÃ¡rio mais comum para utilizarmos `classes` ou `interfaces` Ã© quando fazemos chamadas em API para que os dados sejam exibidos em nosso front-end. Para a execuÃ§Ã£o dos testes vou utilizar a biblioteca `node-fetch` e a API do Star Wars: [https://swapi.co/](https://swapi.co/).

- Instalando a biblioteca `node-fetch`

```bash
$ npm install node-fetch
```

- Construindo a chamada da API

```typescript
// src/index.ts

import * as fetch from 'node-fetch';

fetch('http://swapi.co/api/people/1')
  .then((response) => response.json())
  .then((person) => {
    console.log(person.name);
  });
```

O ponto mais importante a observar no cÃ³digo acima, Ã© que `person` serÃ¡ **implicitamente** do tipo `any`, pois o compilador nÃ£o tem como identificar seu tipo automaticamente. Como o tipo de `person` Ã© `any`, o _IntelliSense_ nÃ£o Ã© capaz de reconhecer o tipo.

![a](images/typescript-any.gif)

Ã‰ nesse ponto que precisaremos definir o nosso modelo. E a pergunta que nÃ£o quer calar:

> Devo utilizar classes ou interfaces?

## Analisando o comportamento com Interfaces

Para o nosso primeiro teste, iremos construir nosso modelo utilizando `interface`.

```typescript
// src/index.ts

import * as fetch from 'node-fetch';

interface Person {
  name: String;
}

fetch('http://swapi.co/api/people/1')
  .then((response) => response.json())
  .then((person: Person) => {
    console.log(person.name);
  });
```

No cÃ³digo acima, estamos definindo **explicitamente** que o tipo de `person` Ã© `Person`. Como o tipo de `person` estÃ¡ explicitamente definido, o `IntelliSense` Ã© capaz de reconhecer o tipo.

![a](images/typescript-interface.gif)

- Analisando o resultado da transpilaÃ§Ã£o

Transpilando o cÃ³digo acima para `javascript` temos o seguinte resultado.

```javascript
// build/index.js

var fetch = require('node-fetch');
fetch('http://swapi.co/api/people/1')
  .then(function(response) {
    return response.json();
  })
  .then(function(person) {
    console.log(person.name);
  });
```

## Analisando o comportamento com Classes

Para o nosso Ãºltimo teste, iremos construir nosso modelo utilizando `class`.

```typescript
// src/index.ts

import * as fetch from 'node-fetch';

class Person {
  name: String;
}

fetch('http://swapi.co/api/people/1')
  .then((response) => response.json())
  .then((person: Person) => {
    console.log(person.name);
  });
```

No cÃ³digo acima, estamos definindo **explicitamente** que o tipo de `person` Ã© `Person`. Como o tipo de `person` estÃ¡ explicitamente definido, o `IntelliSense` Ã© capaz de reconhecer o tipo.

![a](images/typescript-class.gif)

- Analisando o resultado da transpilaÃ§Ã£o

Transpilando o cÃ³digo acima para `javascript` temos o seguinte resultado.

```javascript
// build/index.js

var fetch = require('node-fetch');
var Person = (function() {
  function Person() {}
  return Person;
})();
fetch('http://swapi.co/api/people/1')
  .then(function(response) {
    return response.json();
  })
  .then(function(person) {
    console.log(person.name);
  });
```

WOW ğŸ˜¯ğŸ˜¯ğŸ˜¯!

Reparem que a classe `Person` foi transpilada para o cÃ³digo `javascript` mas nÃ£o Ã© utilizada em nenhuma parte do cÃ³digo.

Esse cÃ³digo Ã© totalmente inÃºtil.

```javascript
// build/index.js

...
var Person = (function () {
    function Person() {
    }
    return Person;
}());
...
```

## ConclusÃ£o

Acredito que tenha ficado claro qual a melhor forma de representar os modelos de dados. As `interfaces` irÃ£o representar os dados, mas serÃ£o completamente removidas durante a transpilaÃ§Ã£o. O grande problema de utilizar `classes` Ã© a quantidade de cÃ³digo desnecessÃ¡rio que serÃ¡ gerado em um projeto com dezenas de objetos.
